/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../common";

export type AssetStruct = { token: string; amount: BigNumberish };

export type AssetStructOutput = [string, BigNumber] & {
  token: string;
  amount: BigNumber;
};

export type CallStruct = {
  target: string;
  callData: BytesLike;
  value: BigNumberish;
};

export type CallStructOutput = [string, string, BigNumber] & {
  target: string;
  callData: string;
  value: BigNumber;
};

export type CallByUserStruct = {
  user: string;
  nonce: BigNumberish;
  asset: AssetStruct;
  chainId: BigNumberish;
  signature: BytesLike;
  calls: CallStruct[];
};

export type CallByUserStructOutput = [
  string,
  BigNumber,
  AssetStructOutput,
  BigNumber,
  string,
  CallStructOutput[]
] & {
  user: string;
  nonce: BigNumber;
  asset: AssetStructOutput;
  chainId: BigNumber;
  signature: string;
  calls: CallStructOutput[];
};

export declare namespace ECDSA {
  export type PublicKeyStruct = { x: BigNumberish; y: BigNumberish };

  export type PublicKeyStructOutput = [BigNumber, BigNumber] & {
    x: BigNumber;
    y: BigNumber;
  };

  export type SignatureStruct = {
    r: BigNumberish;
    s: BigNumberish;
    yParity: BigNumberish;
  };

  export type SignatureStructOutput = [BigNumber, BigNumber, number] & {
    r: BigNumber;
    s: BigNumber;
    yParity: number;
  };
}

export declare namespace SignatureVerification {
  export type KeyStruct = {
    expiry: BigNumberish;
    keyType: BigNumberish;
    publicKey: ECDSA.PublicKeyStruct;
  };

  export type KeyStructOutput = [
    BigNumber,
    number,
    ECDSA.PublicKeyStructOutput
  ] & {
    expiry: BigNumber;
    keyType: number;
    publicKey: ECDSA.PublicKeyStructOutput;
  };
}

export interface ExperimentalDelegationInterface extends utils.Interface {
  functions: {
    "DESTINATION_SETTLER()": FunctionFragment;
    "authorize((uint256,uint8,(uint256,uint256))[])": FunctionFragment;
    "authorize((uint256,uint8,(uint256,uint256))[],bytes)": FunctionFragment;
    "execute(bytes)": FunctionFragment;
    "execute(bytes,bytes)": FunctionFragment;
    "getKeys()": FunctionFragment;
    "initialize(string,(uint256,uint8,(uint256,uint256))[],(uint256,uint256,uint8))": FunctionFragment;
    "initialize(string,(uint256,uint8,(uint256,uint256))[])": FunctionFragment;
    "keys(uint256)": FunctionFragment;
    "label()": FunctionFragment;
    "nonce()": FunctionFragment;
    "revoke(uint32)": FunctionFragment;
    "revoke(uint32,bytes)": FunctionFragment;
    "xExecute((address,uint256,(address,uint256),uint64,bytes,(address,bytes,uint256)[]))": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "DESTINATION_SETTLER"
      | "authorize((uint256,uint8,(uint256,uint256))[])"
      | "authorize((uint256,uint8,(uint256,uint256))[],bytes)"
      | "execute(bytes)"
      | "execute(bytes,bytes)"
      | "getKeys"
      | "initialize(string,(uint256,uint8,(uint256,uint256))[],(uint256,uint256,uint8))"
      | "initialize(string,(uint256,uint8,(uint256,uint256))[])"
      | "keys"
      | "label"
      | "nonce"
      | "revoke(uint32)"
      | "revoke(uint32,bytes)"
      | "xExecute"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "DESTINATION_SETTLER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "authorize((uint256,uint8,(uint256,uint256))[])",
    values: [SignatureVerification.KeyStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "authorize((uint256,uint8,(uint256,uint256))[],bytes)",
    values: [SignatureVerification.KeyStruct[], BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "execute(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "execute(bytes,bytes)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "getKeys", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "initialize(string,(uint256,uint8,(uint256,uint256))[],(uint256,uint256,uint8))",
    values: [string, SignatureVerification.KeyStruct[], ECDSA.SignatureStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize(string,(uint256,uint8,(uint256,uint256))[])",
    values: [string, SignatureVerification.KeyStruct[]]
  ): string;
  encodeFunctionData(functionFragment: "keys", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "label", values?: undefined): string;
  encodeFunctionData(functionFragment: "nonce", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "revoke(uint32)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "revoke(uint32,bytes)",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "xExecute",
    values: [CallByUserStruct]
  ): string;

  decodeFunctionResult(
    functionFragment: "DESTINATION_SETTLER",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "authorize((uint256,uint8,(uint256,uint256))[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "authorize((uint256,uint8,(uint256,uint256))[],bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "execute(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "execute(bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getKeys", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "initialize(string,(uint256,uint8,(uint256,uint256))[],(uint256,uint256,uint8))",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initialize(string,(uint256,uint8,(uint256,uint256))[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "keys", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "label", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "nonce", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "revoke(uint32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revoke(uint32,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "xExecute", data: BytesLike): Result;

  events: {};
}

export interface ExperimentalDelegation extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ExperimentalDelegationInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DESTINATION_SETTLER(overrides?: CallOverrides): Promise<[string]>;

    "authorize((uint256,uint8,(uint256,uint256))[])"(
      keys_: SignatureVerification.KeyStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    "authorize((uint256,uint8,(uint256,uint256))[],bytes)"(
      keys_: SignatureVerification.KeyStruct[],
      signature: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    "execute(bytes)"(
      calls: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    "execute(bytes,bytes)"(
      calls: BytesLike,
      signature: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getKeys(
      overrides?: CallOverrides
    ): Promise<[SignatureVerification.KeyStructOutput[]]>;

    "initialize(string,(uint256,uint8,(uint256,uint256))[],(uint256,uint256,uint8))"(
      label_: string,
      keys_: SignatureVerification.KeyStruct[],
      signature: ECDSA.SignatureStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    "initialize(string,(uint256,uint8,(uint256,uint256))[])"(
      label_: string,
      keys_: SignatureVerification.KeyStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    keys(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number, ECDSA.PublicKeyStructOutput] & {
        expiry: BigNumber;
        keyType: number;
        publicKey: ECDSA.PublicKeyStructOutput;
      }
    >;

    label(overrides?: CallOverrides): Promise<[string]>;

    nonce(overrides?: CallOverrides): Promise<[BigNumber]>;

    "revoke(uint32)"(
      keyIndex: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    "revoke(uint32,bytes)"(
      keyIndex: BigNumberish,
      signature: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    xExecute(
      userCalls: CallByUserStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  DESTINATION_SETTLER(overrides?: CallOverrides): Promise<string>;

  "authorize((uint256,uint8,(uint256,uint256))[])"(
    keys_: SignatureVerification.KeyStruct[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  "authorize((uint256,uint8,(uint256,uint256))[],bytes)"(
    keys_: SignatureVerification.KeyStruct[],
    signature: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  "execute(bytes)"(
    calls: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  "execute(bytes,bytes)"(
    calls: BytesLike,
    signature: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getKeys(
    overrides?: CallOverrides
  ): Promise<SignatureVerification.KeyStructOutput[]>;

  "initialize(string,(uint256,uint8,(uint256,uint256))[],(uint256,uint256,uint8))"(
    label_: string,
    keys_: SignatureVerification.KeyStruct[],
    signature: ECDSA.SignatureStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  "initialize(string,(uint256,uint8,(uint256,uint256))[])"(
    label_: string,
    keys_: SignatureVerification.KeyStruct[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  keys(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, number, ECDSA.PublicKeyStructOutput] & {
      expiry: BigNumber;
      keyType: number;
      publicKey: ECDSA.PublicKeyStructOutput;
    }
  >;

  label(overrides?: CallOverrides): Promise<string>;

  nonce(overrides?: CallOverrides): Promise<BigNumber>;

  "revoke(uint32)"(
    keyIndex: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  "revoke(uint32,bytes)"(
    keyIndex: BigNumberish,
    signature: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  xExecute(
    userCalls: CallByUserStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    DESTINATION_SETTLER(overrides?: CallOverrides): Promise<string>;

    "authorize((uint256,uint8,(uint256,uint256))[])"(
      keys_: SignatureVerification.KeyStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    "authorize((uint256,uint8,(uint256,uint256))[],bytes)"(
      keys_: SignatureVerification.KeyStruct[],
      signature: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "execute(bytes)"(
      calls: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "execute(bytes,bytes)"(
      calls: BytesLike,
      signature: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    getKeys(
      overrides?: CallOverrides
    ): Promise<SignatureVerification.KeyStructOutput[]>;

    "initialize(string,(uint256,uint8,(uint256,uint256))[],(uint256,uint256,uint8))"(
      label_: string,
      keys_: SignatureVerification.KeyStruct[],
      signature: ECDSA.SignatureStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    "initialize(string,(uint256,uint8,(uint256,uint256))[])"(
      label_: string,
      keys_: SignatureVerification.KeyStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    keys(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number, ECDSA.PublicKeyStructOutput] & {
        expiry: BigNumber;
        keyType: number;
        publicKey: ECDSA.PublicKeyStructOutput;
      }
    >;

    label(overrides?: CallOverrides): Promise<string>;

    nonce(overrides?: CallOverrides): Promise<BigNumber>;

    "revoke(uint32)"(
      keyIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "revoke(uint32,bytes)"(
      keyIndex: BigNumberish,
      signature: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    xExecute(
      userCalls: CallByUserStruct,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {};

  estimateGas: {
    DESTINATION_SETTLER(overrides?: CallOverrides): Promise<BigNumber>;

    "authorize((uint256,uint8,(uint256,uint256))[])"(
      keys_: SignatureVerification.KeyStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    "authorize((uint256,uint8,(uint256,uint256))[],bytes)"(
      keys_: SignatureVerification.KeyStruct[],
      signature: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    "execute(bytes)"(
      calls: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    "execute(bytes,bytes)"(
      calls: BytesLike,
      signature: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getKeys(overrides?: CallOverrides): Promise<BigNumber>;

    "initialize(string,(uint256,uint8,(uint256,uint256))[],(uint256,uint256,uint8))"(
      label_: string,
      keys_: SignatureVerification.KeyStruct[],
      signature: ECDSA.SignatureStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    "initialize(string,(uint256,uint8,(uint256,uint256))[])"(
      label_: string,
      keys_: SignatureVerification.KeyStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    keys(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    label(overrides?: CallOverrides): Promise<BigNumber>;

    nonce(overrides?: CallOverrides): Promise<BigNumber>;

    "revoke(uint32)"(
      keyIndex: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    "revoke(uint32,bytes)"(
      keyIndex: BigNumberish,
      signature: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    xExecute(
      userCalls: CallByUserStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DESTINATION_SETTLER(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "authorize((uint256,uint8,(uint256,uint256))[])"(
      keys_: SignatureVerification.KeyStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    "authorize((uint256,uint8,(uint256,uint256))[],bytes)"(
      keys_: SignatureVerification.KeyStruct[],
      signature: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    "execute(bytes)"(
      calls: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    "execute(bytes,bytes)"(
      calls: BytesLike,
      signature: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getKeys(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "initialize(string,(uint256,uint8,(uint256,uint256))[],(uint256,uint256,uint8))"(
      label_: string,
      keys_: SignatureVerification.KeyStruct[],
      signature: ECDSA.SignatureStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    "initialize(string,(uint256,uint8,(uint256,uint256))[])"(
      label_: string,
      keys_: SignatureVerification.KeyStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    keys(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    label(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nonce(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "revoke(uint32)"(
      keyIndex: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    "revoke(uint32,bytes)"(
      keyIndex: BigNumberish,
      signature: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    xExecute(
      userCalls: CallByUserStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
